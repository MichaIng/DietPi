#!/bin/bash
{
	# ////////////////////////////////////
	# DietPi Drive Manager
	#
	#////////////////////////////////////
	# Created by Daniel Knight / daniel.knight@dietpi.com / dietpi.com
	#
	#////////////////////////////////////
	#
	# Info: Drive Manager for DietPi
	#
	# Usage:
	# 	  = Drive Manager
	#	1 = Selectadrive! Provides a list of available drive mount locations, with value on selection saved to: /tmp/dietpi-drive_manager_selmnt
	#	3 = Returns exit 1 if rootfs is currently RO (NB: simple check via mount cmd, does not init full drive manager vars, for quicker loading/processing)
	#	4 = Generates a new /etc/fstab based on current mounted locally drives (for use in PREP_SYSTEM_FOR_DIETPI.sh). NB: does not include remoteFS mounts!
	#
	#////////////////////////////////////

	#Import DietPi-Globals ---------------------------------------------------------------
	. /DietPi/dietpi/func/dietpi-globals
	G_CHECK_ROOT_USER
	export G_PROGRAM_NAME='DietPi-Drive_Manager'
	G_INIT
	#Import DietPi-Globals ---------------------------------------------------------------

	#Grab Input (valid interger)
	INPUT=0
	G_CHECK_VALIDINT $1 && INPUT=$1

	EXIT_CODE=0

	PROGRAM_NAME='DietPi-Drive Manager'

	#Service control for script
	SERVICE_CONTROL=1

	#Return values
	FP_DRIVE_MANAGER_SELECTION='/tmp/dietpi-drive_manager_selmnt'

	#FP
	FP_TEMP_FSTAB='/tmp/.fstab'


	#Drive data
	FP_ROOTFS_SOURCE=0
	FP_USERDATA_CURRENT=0
	FP_SWAPFILE_CURRENT=0

	INDEX_DRIVE_BEING_EDITED=0
	DRIVE_TARGET_BEING_EDITED=''

	FORMAT_GPT=1 # default GPT: https://github.com/Fourdee/DietPi/issues/531. 0=MBR
	FORMAT_FILESYSTEM_TYPE=0 #0=ext4 1=ntfs 2=fat32 3=hfs+ 4=btrfs 5=f2fs 6=exfat
	FORMAT_RECREATE_PARTITION_TABLE=1 #0=for rootfs transfer
	FORMAT_COMPLETED=0
	FORMAT_PREVIOUS_MOUNT_SOURCE='' #Used to obtain previous mount source fp, before a format, for rootfs transfer
	FORMAT_PREVIOUS_MOUNT_TARGET=''

	INDEX_INIT_CURRENT_DEVICE=-1
	Init_New_Device(){

		((INDEX_INIT_CURRENT_DEVICE++))

		aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_PART_UUID[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SIZE_TOTAL[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SIZE_USED[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SIZE_PERCENTUSED[$INDEX_INIT_CURRENT_DEVICE]=''
		aDRIVE_SIZE_FREE[$INDEX_INIT_CURRENT_DEVICE]=''

		aDRIVE_ISFILESYSTEM[$INDEX_INIT_CURRENT_DEVICE]=0
		aDRIVE_ISMOUNTED[$INDEX_INIT_CURRENT_DEVICE]=0
		aDRIVE_ISREADONLY_CURRENTLY[$INDEX_INIT_CURRENT_DEVICE]=0
		aDRIVE_ISNETWORKED[$INDEX_INIT_CURRENT_DEVICE]=0

	}

	Destroy(){

		INDEX_INIT_CURRENT_DEVICE=-1

		#Delete []
		unset aDRIVE_MOUNT_SOURCE
		unset aDRIVE_MOUNT_TARGET
		unset aDRIVE_SOURCE_DEVICE
		unset aDRIVE_FSTYPE
		unset aDRIVE_SIZE_TOTAL
		unset aDRIVE_SIZE_USED
		unset aDRIVE_SIZE_PERCENTUSED
		unset aDRIVE_SIZE_FREE
		unset aDRIVE_PART_UUID
		unset aDRIVE_UUID

		unset aDRIVE_ISMOUNTED
		unset aDRIVE_ISFILESYSTEM
		unset aDRIVE_ISREADONLY_CURRENTLY
		unset aDRIVE_ISNETWORKED

	}

	Init_Drives_and_Refresh(){

		#---------------------------------------------------------------
		#Delete arrays before reinit
		Destroy

		# - Obtain actual user data location on disk (follows symlinks)
		FP_USERDATA_CURRENT="$(readlink -f $G_FP_DIETPI_USERDATA)"

		# - Swapfile location
		FP_SWAPFILE_CURRENT="$(grep -m1 '^[[:blank:]]*AUTO_SETUP_SWAPFILE_LOCATION=' /DietPi/dietpi.txt | sed 's/.*=//')"

		# - ROOTFS location
		FP_ROOTFS_SOURCE=$(findmnt / -o source -n)

		#Recreate FStab
		local var_log_size=$(grep -m1 '^AUTO_SETUP_RAMLOG_MAXSIZE=' /DietPi/dietpi.txt | sed 's/^.*=//')
		if [[ -z $var_log_size ]]; then

			var_log_size=20

		fi

		#Grab network mounts + creds
		cp /etc/fstab $FP_TEMP_FSTAB
		local net_mounts_samba=$(grep '[[:space:]]cifs[[:space:]]' $FP_TEMP_FSTAB)
		local net_mounts_nfs4=$(grep '[[:space:]]nfs4[[:space:]]' $FP_TEMP_FSTAB)
		local net_mounts_ftp=$(grep '^curlftpfs' $FP_TEMP_FSTAB)
		#nfs4
		#cifs spacebothsides
		#curlftpfs

		cat << _EOF_ > $FP_TEMP_FSTAB
#Network Mounts -------------------------------------------------
#Please use dietpi-config and the Networking Options: NAS menu to setup this mount
$net_mounts_samba
$net_mounts_ftp
$net_mounts_nfs4

#TMPFS / MISC ------------------------------------------------------
proc            /proc           proc    defaults											0 0
tmpfs 			/tmp  			tmpfs 	defaults,noatime,nodev,nosuid,mode=1777				0 0
tmpfs 			/var/log 		tmpfs 	defaults,size=${var_log_size}m,noatime,nodev,nosuid,mode=1777	0 0
tmpfs 			/DietPi 		tmpfs 	defaults,size=10m,noatime,nodev,nosuid,mode=1777	0 0

#Internal Drives---------------------------------------------------
_EOF_

		#Detect mounted drives and add them to fstab
		G_DIETPI-NOTIFY 2 'Detecting drives, please wait...'
		local cmd_scrape_string=''
		local index=0
		G_DIETPI-NOTIFY 0 'Detecting currently mounted drives, please wait...'
		df -Ph | tail -n +2 | sed '/tmpfs/d' | sed '/^udev/d' > /tmp/.dietpi-drive_manager_df_tmp
		while read line
		do

			if [[ -z $line ]]; then

				break

			fi

			Init_New_Device

			aDRIVE_ISMOUNTED[$INDEX_INIT_CURRENT_DEVICE]=1
			aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]=$(echo $line | awk '{print $1}')
			aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]=$(echo $line | awk '{print $6}')
			#	Workaround for /dev/root under RPi, force psyhical location
			if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} == '/' ]]; then

				aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]=$FP_ROOTFS_SOURCE

			fi

			aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]=$(Return_Drive_Without_Partitions ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} | sed 's/\/dev\///')
			# - Networked?
			if [[ ! -d '/sys/block/'${aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]} ]]; then

				aDRIVE_ISNETWORKED[$INDEX_INIT_CURRENT_DEVICE]=1
				aDRIVE_ISFILESYSTEM[$INDEX_INIT_CURRENT_DEVICE]=1
				aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]='Net'

			fi

			G_DIETPI-NOTIFY 2 " - Detected: ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} > ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]}"

			aDRIVE_SIZE_TOTAL[$INDEX_INIT_CURRENT_DEVICE]=$(echo $line | awk '{print $2}')
			aDRIVE_SIZE_USED[$INDEX_INIT_CURRENT_DEVICE]=$(echo $line | awk '{print $3}')
			aDRIVE_SIZE_PERCENTUSED[$INDEX_INIT_CURRENT_DEVICE]=$(echo $line | awk '{print $5}')
			aDRIVE_SIZE_FREE[$INDEX_INIT_CURRENT_DEVICE]=$(echo $line | awk '{print $4}')

			aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s UUID -o value)
			aDRIVE_PART_UUID[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s PARTUUID -o value)

			cmd_scrape_string=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s TYPE -o value)
			if [[ $cmd_scrape_string ]]; then

				aDRIVE_ISFILESYSTEM[$INDEX_INIT_CURRENT_DEVICE]=1
				aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]=$cmd_scrape_string

			fi

			#RO mounted?
			#NB: We cant use -m1 for initial check as results can be:
			# root@DietPi:~# cat /proc/mounts | grep ' / '
			# rootfs / rootfs rw 0 0
			# /dev/mmcblk0p2 / ext4 ro,noatime,discard,data=ordered 0 0
			cmd_scrape_string=$(grep "[[:space:]]${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]}[[:space:]]" /proc/mounts | grep -m1 '[[:space:]]ro,')
			if [[ $cmd_scrape_string ]]; then

				aDRIVE_ISREADONLY_CURRENTLY[$INDEX_INIT_CURRENT_DEVICE]=1

				# - RootFS RW check
				if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} == '/' ]]; then

					G_DIETPI-NOTIFY 2 "RootFS is currently set to R/O. $PROGRAM_NAME requires R/W access."

					G_WHIP_YESNO "RootFS is currently set to 'Read Only'. DietPi-Drive_Manager requires 'Read Write' access to function.\n\nWould you like to renable 'Read Write' access on RootFS?"
					if (( $? == 0 )); then

						G_RUN_CMD mount -v -o rw,remount
						G_DIETPI-NOTIFY 0 "RootFS R/W now enabled."

					else

						/DietPi/dietpi/dietpi-services start

						G_DIETPI-NOTIFY 0 'RootFS currently set to R/O.'
						G_DIETPI-NOTIFY 2 "Please run 'dietpi-drive_manager' again, if you want to re-enable RootFS R/W."

						Destroy
						exit

					fi

				fi

			fi

			# - Add entry to fstab
			if [[ -n ${aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]} ]]; then

				local string_readonly='rw'
				if (( ${aDRIVE_ISREADONLY_CURRENTLY[$INDEX_INIT_CURRENT_DEVICE]} )); then

					string_readonly='ro'

				fi
				cat << _EOF_ >> $FP_TEMP_FSTAB
UUID=${aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]} ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} auto $string_readonly,noatime 0 0
_EOF_

			fi

		done < /tmp/.dietpi-drive_manager_df_tmp
		rm /tmp/.dietpi-drive_manager_df_tmp

		#Check blkid for unmounted drives, if drive is not mounted, add entry as disabled mount
		G_DIETPI-NOTIFY 0 'Detecting unmounted drives, please wait...'
		blkid -o device > /tmp/.dietpi-drive_manager_blkid_tmp
		while read line
		do

			if [[ -z $line ]]; then

				break

			fi

			for ((i=0; i<${#aDRIVE_MOUNT_SOURCE[@]}; i++))
			do

				if [[ ${aDRIVE_MOUNT_SOURCE[$i]} == $line ]]; then

					break

				fi

				# - New unmounted drive found on system, add entry to fstab
				#	Must have a valid UUID! (this excludes /dev/mmcblk0)
				if (( $i == ( ${#aDRIVE_MOUNT_SOURCE[@]} - 1 ) )) &&
					[[ -n $(blkid $line -s UUID -o value) ]]; then

					G_DIETPI-NOTIFY 2 " - Detected unmounted drive: $line, updating fstab"

					Init_New_Device

					aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]=$line
					aDRIVE_SOURCE_DEVICE[$INDEX_INIT_CURRENT_DEVICE]=$(Return_Drive_Without_Partitions ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} | sed 's/\/dev\///')

					aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s UUID -o value)
					aDRIVE_PART_UUID[$INDEX_INIT_CURRENT_DEVICE]=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s PARTUUID -o value)

					aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]="/mnt/${aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]}"

					cmd_scrape_string=$(blkid ${aDRIVE_MOUNT_SOURCE[$INDEX_INIT_CURRENT_DEVICE]} -s TYPE -o value)
					if [[ $cmd_scrape_string ]]; then

						aDRIVE_ISFILESYSTEM[$INDEX_INIT_CURRENT_DEVICE]=1
						aDRIVE_FSTYPE[$INDEX_INIT_CURRENT_DEVICE]=$cmd_scrape_string

					fi

					cat << _EOF_ >> $FP_TEMP_FSTAB
#UUID=${aDRIVE_UUID[$INDEX_INIT_CURRENT_DEVICE]} ${aDRIVE_MOUNT_TARGET[$INDEX_INIT_CURRENT_DEVICE]} auto noatime 0 0
_EOF_

				fi

			done

		done < /tmp/.dietpi-drive_manager_blkid_tmp
		rm /tmp/.dietpi-drive_manager_blkid_tmp

		#Remove x-systemd.automount if not supported by kernel: https://github.com/Fourdee/DietPi/issues/1607#issuecomment-372030565
		if ! modprobe autofs4 --dry-run &> /dev/null; then

			sed -i 's/,x-systemd.automount//g' $FP_TEMP_FSTAB
			G_DIETPI-NOTIFY 2 'autofs4 module not available in kernel, x-systemd.automount has been disabled'

		fi

		#Find the drive we are to edit, then set its index (this is due to array list total being not constant)
		if [[ -n $DRIVE_TARGET_BEING_EDITED ]]; then

			for ((i=0; i<${#aDRIVE_MOUNT_SOURCE[@]}; i++))
			do

				if [[ $DRIVE_TARGET_BEING_EDITED == ${aDRIVE_MOUNT_TARGET[$i]} ]]; then

					INDEX_DRIVE_BEING_EDITED=$i
					break

				fi

			done

		fi

		cp $FP_TEMP_FSTAB /etc/fstab
		systemctl daemon-reload

		rm $FP_TEMP_FSTAB

		sync
		mount -a

	}

	Return_Drive_Without_Partitions(){

		#$1 = dev source
		if [[ $1 == '/dev/sd'* ]]; then

			echo $1 | sed 's/[0-9]$//'

		#mmc
		else

			echo $1 | sed 's/p[0-9]$//'

		fi

	}

	#$1=source $2=target
	Mount_Drive(){

		local source=$1
		local target=$2
		if [[ ! -d $target ]]; then

			G_DIETPI-NOTIFY 2 "Creating mount folder for $target"
			mkdir -p $target

		fi

		G_RUN_CMD_INFO_ONLY=1 G_RUN_CMD mount $source $target

	}

	#$=target
	Unmount_Drive(){

		local target=$1

		G_RUN_CMD_INFO_ONLY=1 G_RUN_CMD umount $target
		if (( $? == 0 )); then

			sed -i "\#[[:space:]]$target[[:space:]]#d" /etc/fstab #Only needed for networked drives currently...
			rm -R $target

		fi

	}

	Run_Format(){

		# - Unmount drive
		umount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		if (( $FORMAT_RECREATE_PARTITION_TABLE )); then

			# - Clear MBR and partition table from device, and then some.
			dd if=/dev/zero of=/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} bs=5M count=1

			# - Create partition table type
			local parition_table_type='msdos'
			if (( $FORMAT_GPT )); then

				parition_table_type='gpt'

			fi

			G_DIETPI-NOTIFY 2 "Partition table target: $parition_table_type"

			parted -s /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} mklabel $parition_table_type
			parted -a optimal /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]} mkpart primary 0% 100%

			# parted -s "${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}" mklabel "$parition_table_type"
			# parted -a optimal "${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}" mkpart primary 0% 100%

			#partprobe #this mounts all drives

			sleep 1 # due to systemD automount, wait for it.
			umount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		else

			# - Clear partition from device
			dd if=/dev/zero of=/dev/${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} bs=5M count=1

		fi

		# - Format ext4
		if (( $FORMAT_FILESYSTEM_TYPE == 0 )); then

			# force
			mkfs.ext4 -F -m 0 ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}
			resize2fs ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		# - Format NTFS
		elif (( $FORMAT_FILESYSTEM_TYPE == 1 )); then

			# fast format / no indexing / force
			mkfs.ntfs -f -I -F ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		# - Format FAT32
		elif (( $FORMAT_FILESYSTEM_TYPE == 2 )); then

			#  use 1 parition on whole device
			mkfs.vfat -I ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		# - Format HFS+
		elif (( $FORMAT_FILESYSTEM_TYPE == 3 )); then

			mkfs.hfsplus ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		# - Format btrfs
		elif (( $FORMAT_FILESYSTEM_TYPE == 4 )); then

			# force
			mkfs.btrfs -f ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		# - Format f2fs
		elif (( $FORMAT_FILESYSTEM_TYPE == 5 )); then

			mkfs.f2fs ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		# - Format exFAT
		elif (( $FORMAT_FILESYSTEM_TYPE == 6 )); then

			mkfs.exfat ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

		fi

		FORMAT_COMPLETED=1
		FORMAT_PREVIOUS_MOUNT_SOURCE=${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}
		FORMAT_PREVIOUS_MOUNT_TARGET=${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}

		Init_Drives_and_Refresh

		local format_new_uuid=$(blkid $FORMAT_PREVIOUS_MOUNT_SOURCE -s UUID -o value)

		rm -R $FORMAT_PREVIOUS_MOUNT_TARGET

		# - Automatically mount it
		Mount_Drive $FORMAT_PREVIOUS_MOUNT_SOURCE /mnt/$format_new_uuid
		DRIVE_TARGET_BEING_EDITED="/mnt/$format_new_uuid"

		Init_Drives_and_Refresh

	}

	RootFS_Move(){

		#Remove previous fstab entry and mount location
		cp /etc/fstab /etc/fstab.bak #incase of Rsync fail

		#	Remove automatic entry for new uuid
		sed -i "\@[[:space:]]${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}[[:space:]]@d" /etc/fstab

		#	Add new rootfs entry
		sed -i "\@[[:space:]]/[[:space:]]auto@c UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]} / auto defaults,noatime 0 1" /etc/fstab

		# - install rsync
		G_AG_CHECK_INSTALL_PREREQ rsync

		rsync -aHv --delete --exclude '/lost+found/' --exclude ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}/ --exclude '/sys/*' --exclude '/proc/*' / "${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}"/
		if (( $? )); then

			G_DIETPI-NOTIFY 1 'Rsync has failed, RootFS transfer has been aborted.'
			#	revert FSTAB changes
			cp /etc/fstab.bak /etc/fstab

			Destroy
			exit

		fi

		#RPi | cmdline.txt
		if (( $G_HW_MODEL < 10 )); then

			#	find current root= and replace
			local rootfs_current=$(awk '{for(i=1;i<=NF;i++) {print $i} }' /boot/cmdline.txt | grep -m1 'root=')
			sed -i "s#$rootfs_current#root=PARTUUID=${aDRIVE_PART_UUID[$INDEX_DRIVE_BEING_EDITED]}#g" /boot/cmdline.txt

			#	Add root delay
			if ! grep -qi '[[:space:]]rootdelay=' /boot/cmdline.txt; then

				sed -i "s#console=tty1#console=tty1 rootdelay=10#g" /boot/cmdline.txt

			fi

			#	set FS type
			local rootfstype_current=$(awk '{for(i=1;i<=NF;i++) {print $i} }' /boot/cmdline.txt | grep -m1 'rootfstype=')
			sed -i "s#$rootfstype_current#rootfstype=${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]}#g" /boot/cmdline.txt

		#C1/C2/XU4 | /DietPi/boot.ini
		elif (( $G_HW_MODEL == 10 || $G_HW_MODEL == 11 || $G_HW_MODEL == 12 )); then

			#	find current root= to replace
			local rootfs_current=$(awk '{for(i=1;i<=NF;i++) {print $i} }' /DietPi/boot.ini | grep -m1 'root=' | sed 's/\"//')
			sed -i "s#$rootfs_current#root=UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}#g" /DietPi/boot.ini

		fi

		systemctl daemon-reload

		G_WHIP_MSG 'RootFS transfer completed. Press enter to reboot system.'

		reboot

	}

	RootFS_Low_Free_Space_Check(){

		#	global min limit (MB)
		local free_space_limit=500

		G_DIETPI-NOTIFY 2 'Checking available free space on RootFS, please wait...'

		#Find rootfs
		for ((i=0; i<${#aDRIVE_MOUNT_SOURCE[@]}; i++))
		do

			if [[ ${aDRIVE_MOUNT_TARGET[$i]} == '/' ]]; then

				INDEX_DRIVE_BEING_EDITED=$i

				#	Obtain free space (MB)
				local free_space_current=$(df -B M | grep -m1 "${aDRIVE_MOUNT_TARGET[$i]}$" | awk '{print $4}' | sed 's/[^0-9]//g')

				if (( $free_space_current < $free_space_limit )); then

					G_WHIP_MSG "Error:\n\nAvailable free space on RootFS is low ($free_space_current MB). To prevent potential issues due to running out of free space, this script will now be terminated.\n\nPlease free up at least $free_space_limit MB of free space, then try again."

					G_DIETPI-NOTIFY 1 "Insufficient free space on RootFS. $free_space_current MB available, $free_space_limit MB required"

					#	export
					EXIT_CODE=1

				else

					G_DIETPI-NOTIFY 0 "$free_space_current MB available, $free_space_limit MB required"

				fi

				break

			fi

		done

		#Still waiting for Freespace 3 :(

	}

	RootFS_RW_Check(){

		if mount | grep -m1 '[[:blank:]]/[[:blank:]]' | grep -q '(ro,'; then

			G_DIETPI-NOTIFY 1 'RootFS is currently set to R/O.'
			G_DIETPI-NOTIFY 2 "DietPi requires RootFS R/W access. Please run 'dietpi-drive_manager' to re-enable.\n"
			EXIT_CODE=1

		else

			G_DIETPI-NOTIFY 0 'RootFS R/W access verified.\n'

		fi

	}

	Toggle_WriteMode(){

		local exit_status=0
		local message_result=0

		if (( ${aDRIVE_ISREADONLY_CURRENTLY[$INDEX_DRIVE_BEING_EDITED]} )); then

			message_result=$(mount -v -o rw,remount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} 2>&1)
			exit_status=$?

		else

			message_result=$(mount -v -o ro,remount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} 2>&1)
			exit_status=$?

		fi

		if (( $exit_status )); then

			G_WHIP_MSG "Failed to apply:\n\nDue to:\n - $message_result"

		fi

	}

	TARGETMENUID=0
	MENU_LASTITEM=''

	Menu_Main_Drive_Manager(){

		#Generate menu
		G_WHIP_MENU_ARRAY=()

		# - Create a nice category list, to match items to their block device (eg: mmcblk0)
		local acategory_list=()
		for ((i=0; i<${#aDRIVE_MOUNT_SOURCE[@]}; i++))
		do

			local new_cat=1

			for ((j=0; j<${#acategory_list[@]}; j++))
			do

				if [[ ${aDRIVE_SOURCE_DEVICE[$i]} == ${acategory_list[$j]} ]]; then

					new_cat=0
					break

				fi

			done

			# - add
			if (( $new_cat )); then

				acategory_list+=( ${aDRIVE_SOURCE_DEVICE[$i]} )

			fi

		done

		#List all available drives, if no drive found, list info for user.
		local drive_available=0
		for ((i=0; i<${#acategory_list[@]}; i++))
		do

			drive_available=1
			G_WHIP_MENU_ARRAY+=('' "─ ${acategory_list[$i]} ────────────────────────────────────────")

			for ((j=0; j<${#aDRIVE_MOUNT_SOURCE[@]}; j++))
			do

				if [[ ${aDRIVE_SOURCE_DEVICE[$j]} == ${acategory_list[$i]} ]]; then

					local string_fstype=${aDRIVE_FSTYPE[$j]}
					if (( ${aDRIVE_ISNETWORKED[$j]} )); then

						string_fstype='Net'

					fi

					#Drive is fully mounted:
					if (( ${aDRIVE_ISMOUNTED[$j]} )); then

						G_WHIP_MENU_ARRAY+=("${aDRIVE_MOUNT_TARGET[$j]}" ": ${aDRIVE_MOUNT_SOURCE[$j]} | $string_fstype | Size: ${aDRIVE_SIZE_TOTAL[$j]} | Used: ${aDRIVE_SIZE_USED[$j]} (${aDRIVE_SIZE_PERCENTUSED[$j]})")

					#Not mounted, why?
					else

						#Drive has no FS:
						if (( ! ${aDRIVE_ISFILESYSTEM[$j]} )); then

							G_WHIP_MENU_ARRAY+=("${aDRIVE_MOUNT_TARGET[$j]}" ": ${aDRIVE_MOUNT_SOURCE[$j]} | No filesystem / format required")

						#Drive is not mounted:
						else

							G_WHIP_MENU_ARRAY+=("${aDRIVE_MOUNT_TARGET[$j]}" ": ${aDRIVE_MOUNT_SOURCE[$j]} | $string_fstype | Not mounted")

						fi

					fi

				fi

			done

		done

		unset acategory_list

		G_WHIP_MENU_ARRAY+=('' '───────────────────────────────────────────────────────')

		if (( ! $drive_available )); then

			G_WHIP_MENU_ARRAY+=('Refresh' ': No drives found. Insert a drive and select this option')

		else

			G_WHIP_MENU_ARRAY+=('Refresh' ': Scan for recently added/removed drives')

		fi

		G_WHIP_MENU_ARRAY+=('Add network drive' ': Select to mount networked drives')

		# - User data
		local userdata_location_text="RootFS ($FP_USERDATA_CURRENT)"
		if [[ $FP_USERDATA_CURRENT != $G_FP_DIETPI_USERDATA ]]; then

			userdata_location_text="$FP_USERDATA_CURRENT"

		fi

		G_WHIP_DEFAULT_ITEM="$MENU_LASTITEM"
		G_WHIP_BUTTON_CANCEL_TEXT='Exit'
		G_WHIP_MENU "Please select a drive to see available options.\n - User data location: $userdata_location_text"
		if (( ! $? )); then

			MENU_LASTITEM="$G_WHIP_RETURNED_VALUE"

			# - Refresh
			if [[ $G_WHIP_RETURNED_VALUE == 'Refresh' ]]; then

				Init_Drives_and_Refresh


			elif [[ $G_WHIP_RETURNED_VALUE == 'Add network drive' ]]; then

				TARGETMENUID=3

			# - Edit drive
			elif [[ -n $G_WHIP_RETURNED_VALUE ]]; then

				TARGETMENUID=1
				DRIVE_TARGET_BEING_EDITED="$G_WHIP_RETURNED_VALUE"
				Init_Drives_and_Refresh

			fi

		#Exit
		else

			Menu_Exit

		fi

	}

	Notification(){

		local input=$1

		if (( $1 == 0 )); then

			G_WHIP_MSG "Failed\n\nThe DietPi user data is currently located on this drive:\n - $FP_USERDATA_CURRENT\n\nThe requested option for this drive is not currently possible.\n\nPlease move your user data elsewhere, before trying again:\nhttp://dietpi.com/phpbb/viewtopic.php?f=8&t=478"

		elif (( $1 == 1 )); then

			G_WHIP_MSG "Failed\n\nThe DietPi swapfile is currently located on this drive:\n - $FP_SWAPFILE_CURRENT\n\nThe requested option for this drive is not currently possible.\n\nPlease move the swapfile elsewhere, before trying again."

		fi

	}

	Menu_Drive_Manager_Edit_Drive(){

		#Return to this menu
		TARGETMENUID=1

		local partition_contains_userdata=0
		local partition_contains_swapfile=0

		#Generate menu
		local whiptail_desc=''
		G_WHIP_MENU_ARRAY=()

		whiptail_desc="Mount target: ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}"
		whiptail_desc+="\nMount source: ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}"

		#No filesystem
		if (( ! ${aDRIVE_ISFILESYSTEM[$INDEX_DRIVE_BEING_EDITED]} )); then

			whiptail_desc+='\nStatus:       Drive has no known filesystem and must be formatted'
			G_WHIP_MENU_ARRAY+=('Format' ': Wipe all data and format drive with ext4')

		else

			if [[ -n ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} ]]; then

				whiptail_desc+="\nFilesystem:   ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]}"

			fi

			if [[ -n ${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]} ]]; then

				whiptail_desc+="\nUUID:         ${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}"

			fi

			if (( ${aDRIVE_ISMOUNTED[$INDEX_DRIVE_BEING_EDITED]} )); then

				local reserved_blocks_percent_info=''
				local reserved_blocks_percent_current=0
				# Show reserved blocks percentage for ext4 drives behind capacity:
				if [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'ext4' ]]; then

					local fp_temp='/tmp/.dietpi-drive_manager_dumpe2fs'
					dumpe2fs -h "${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}" > "$fp_temp"
					local block_count="$(grep -m1 '^Block count:' $fp_temp | awk '{print $3}')"
					local reserved_block_count="$(grep -m1 '^Reserved block count:' $fp_temp | awk '{print $4}')"
					rm $fp_temp
					reserved_blocks_percent_current="$(bc -l <<< "scale=3;(100*$reserved_block_count)/$block_count")"
					# Correct rounding to final scale:
					reserved_blocks_percent_current="$(bc -l <<< "scale=2;(($reserved_blocks_percent_current*100)+0.5)/100" | sed 's/^\./0\./' | sed '/.0$/s/0$//' | sed 's/\.0$//')"
					reserved_blocks_percent_info=" (Reserved blocks: $reserved_blocks_percent_current%)"
					G_WHIP_MENU_ARRAY+=('Reserved blocks' ': Adjust percentage of reserved blocks on this drive')

				fi

				whiptail_desc+="\nAllocation:   Total = ${aDRIVE_SIZE_TOTAL[$INDEX_DRIVE_BEING_EDITED]}b | Used = ${aDRIVE_SIZE_USED[$INDEX_DRIVE_BEING_EDITED]}b (${aDRIVE_SIZE_PERCENTUSED[$INDEX_DRIVE_BEING_EDITED]})"
				whiptail_desc+='\nStatus:       Drive is online and ready for use'

				#Unmount
				# - Disable mount control for /boot /rootfs
				if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/boot' ]]; then

					if (( ${aDRIVE_ISNETWORKED[$INDEX_DRIVE_BEING_EDITED]} )); then

						G_WHIP_MENU_ARRAY+=('Remove' ': Unmount networked drive and remove it from database')

					else

						G_WHIP_MENU_ARRAY+=('Unmount' ': Allows you to physically remove the drive')

					fi

				fi

				G_WHIP_MENU_ARRAY+=('Benchmark' ': Test read and write speeds')

				#Userdata location/swapfile/Readonly
				if (( ! ${aDRIVE_ISNETWORKED[$INDEX_DRIVE_BEING_EDITED]} )); then

					# - Userdata
					if ( [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' && $FP_USERDATA_CURRENT == ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}* ]] ) || #off rootfs
						( [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' && $FP_USERDATA_CURRENT == $G_FP_DIETPI_USERDATA ]] ); then #on rootfs

						G_WHIP_MENU_ARRAY+=('User data' ": [X] | DietPi user data is currently located on this drive")
						partition_contains_userdata=1

					else

						G_WHIP_MENU_ARRAY+=('User data' ': [ ] | Select to transfer DietPi user data to this drive')

					fi

					# - Swapfile
					#	NB: / rootfs will always be detected in this check, however, no rootFS options for umount and format...
					local swapfile_location="$(grep -m1 '^[[:blank:]]*AUTO_SETUP_SWAPFILE_LOCATION=' /DietPi/dietpi.txt | sed 's/.*=//')"
					local swapfile_size=$(grep -m1 '^[[:blank:]]*AUTO_SETUP_SWAPFILE_SIZE=' /DietPi/dietpi.txt | sed 's/.*=//')
					if [[ $swapfile_location == ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}* && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' ]] ||
						[[ $swapfile_location == '/var/swap' && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' ]]; then

						partition_contains_swapfile=1
						G_WHIP_MENU_ARRAY+=('Swapfile' ": [X] | ${swapfile_size}MB used on this drive, select to change size")

					else

						G_WHIP_MENU_ARRAY+=('Swapfile' ': [ ] | Select to transfer swapfile to this drive')

					fi

					# - Read only?
					local read_only_state='[ ]'
					local read_only_state_text='Disabled'
					if (( ${aDRIVE_ISREADONLY_CURRENTLY[$INDEX_DRIVE_BEING_EDITED]} )); then

						read_only_state='[X]'
						read_only_state_text='Enabled'

					fi
					G_WHIP_MENU_ARRAY+=('Read Only' ": $read_only_state | Select to toggle RW/RO modes")
					whiptail_desc+="\nRead only:    $read_only_state_text"

				fi

			else

				whiptail_desc+='\nStatus:       Drive is not mounted and can be unplugged'
				G_WHIP_MENU_ARRAY+=('Mount' ": Mount the drive to ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}")

			fi

			if (( ! ${aDRIVE_ISNETWORKED[$INDEX_DRIVE_BEING_EDITED]} )); then

				# - Disable check&repair for /boot /rootfs
				if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/boot' ]]; then

					G_WHIP_MENU_ARRAY+=('Check & Repair' ': Check and optionally repair filesystem')

				fi

				#Transfer RootFS
				if [[ ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} != $FP_ROOTFS_SOURCE ]] &&
					(( $G_HW_MODEL < 10 || $G_HW_MODEL == 10 || $G_HW_MODEL == 11 || $G_HW_MODEL == 12 )); then

					G_WHIP_MENU_ARRAY+=('Transfer RootFS' ': Transfer RootFS to this drive')

				fi

				# - Disable format for /boot /rootfs
				if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' && ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/boot' ]]; then

					G_WHIP_MENU_ARRAY+=('Format' ': Wipe all data and format drive with ext4')

				fi

			fi

		fi

		G_WHIP_DEFAULT_ITEM="$MENU_LASTITEM"
		G_WHIP_MENU "$whiptail_desc"
		if (( ! $? )); then

			MENU_LASTITEM="$G_WHIP_RETURNED_VALUE"

			if [[ $G_WHIP_RETURNED_VALUE == 'Mount' ]]; then

				Mount_Drive ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}

			elif [[ $G_WHIP_RETURNED_VALUE == 'Unmount' || $G_WHIP_RETURNED_VALUE == 'Remove' ]]; then

				# - Disallow if userdata is located on this drive!
				if (( $partition_contains_userdata )); then

					Notification 0

				elif (( $partition_contains_swapfile )); then

					Notification 1

				else

					if [[ $G_WHIP_RETURNED_VALUE == 'Remove' ]]; then

						G_WHIP_YESNO "Do you wish to unmount and remove the following networked drive from this system?\n - ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} > ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}\n\nNB: You can add additional network shares at a later date through the 'dietpi-drive_manager' main menu."
						if (( $? == 0 )); then

							Unmount_Drive ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}
							TARGETMENUID=0

						fi

					else

						Unmount_Drive ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}

					fi

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Swapfile' ]]; then

				local min=0
				local current_freespace=$(G_CHECK_FREESPACE ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]})
				local max=$(( $current_freespace - 2000 ))
				if (( $max < $min )); then

					G_WHIP_MSG "Error: Insufficent free space on ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}, a minimum of 2GB is required ($current_freespace MB available)."

				else

					G_WHIP_DEFAULT_ITEM=$swapfile_size
					G_WHIP_INPUTBOX "Please input a new value for swapfile size (MB):\n\nSwapfile has a swapiness setting of 1, and, is used only to prevent out of memory errors.\n\n - Recommended value = 1 (auto)\n - 0 = Disable swapfile\n - 1 = Auto size swapfile (2GB - RAM = size)\n - 2 - $max = Manual size"
					if (( $? == 0 )); then

						if G_CHECK_VALIDINT $G_WHIP_RETURNED_VALUE &&
							(( $G_WHIP_RETURNED_VALUE >= $min && $G_WHIP_RETURNED_VALUE <= $max )); then

							local fp_target_swapfile='/var/swap'
							if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} != '/' ]]; then

								fp_target_swapfile="${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}/.swapfile"

							fi

							/DietPi/dietpi/func/dietpi-set_dphys-swapfile $G_WHIP_RETURNED_VALUE "$fp_target_swapfile"

						else

							G_WHIP_MSG 'Invalid value. No changes applied, please try again.'

						fi

					fi

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Reserved blocks' ]]; then

				while true
				do

					G_WHIP_DEFAULT_ITEM="$reserved_blocks_percent_current"
					G_WHIP_INPUTBOX 'Ext4 formatted drives allow the reservation of drive space for the root user to assure system functionality, if filled by other users or processes, and to avoid fragmentation of large files.\n\nHowever, on modern drives, the default of 5% reserved blocks is often by orders of magnitude larger than necessary. You may want to reduce the percentage to an absolute reserved space of about 500 MiB, which should be enough, to enable root user starting and maintaining the system. Additionally, on non rootfs drives reserved blocks are not necessary at all.\n\nPlease enter the desired percentage of reserved blocks, e.g. "0.05" for 0.05% or "10" for 10%.\nNote: Only values between "0" and "50" are allowed.'
					if (( $? )); then

						break

					else

						if grep -qE '^[0-9]*\.?[0-9]*$' <<< "$G_WHIP_RETURNED_VALUE" &&
							[[ $G_WHIP_RETURNED_VALUE != '.' ]] &&
							(( $(bc -l <<< "$G_WHIP_RETURNED_VALUE <= 50") )); then

							G_RUN_CMD tune2fs -m "$G_WHIP_RETURNED_VALUE" "${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}"
							break

						else

							G_WHIP_MSG 'Error: Allowed are only integers or floats between "0" and "50", e.g. "10" or "0.5".\n\nPlease try again...'

						fi

					fi

				done

			elif [[ $G_WHIP_RETURNED_VALUE == 'User data' ]]; then

				local fp_target_userdata_dir="${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}"
				#	Assign location if under RootFS
				if [[ ${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]} == '/' ]]; then

					fp_target_userdata_dir='/mnt'

				fi

				fp_target_userdata_dir+='/dietpi_userdata'

				if [[ $fp_target_userdata_dir != $FP_USERDATA_CURRENT ]]; then

					G_WHIP_YESNO "Your user data will be moved:\n - From: $FP_USERDATA_CURRENT\n - To: $fp_target_userdata_dir\n\nDo you wish to continue?"
					if (( ! $? )); then

						/DietPi/dietpi/func/dietpi-set_userdata "$FP_USERDATA_CURRENT" "$fp_target_userdata_dir"
						sleep 1

					fi

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Format' ]]; then

				FORMAT_RECREATE_PARTITION_TABLE=1

				# - Disallow if userdata is located on this drive!
				if (( $partition_contains_userdata )); then

					Notification 0

				elif (( $partition_contains_swapfile )); then

					Notification 1

				#	user must unmount all partitions on this drive, before we can format
				elif (( $(df -P | grep -ci -m1 "^/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}") )); then

					df -P | grep -m1 "^/dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}"
					G_WHIP_MSG 'As DietPi will format the entire drive with 1 partition, you must unmount ALL partitions on this disk, before formatting is available.'

				else

					TARGETMENUID=2

				fi

			#Transfer RootFS
			elif [[ $G_WHIP_RETURNED_VALUE == 'Transfer RootFS' ]]; then

				FORMAT_RECREATE_PARTITION_TABLE=0

				#	user must unmount partition before format
				if (( ${aDRIVE_ISMOUNTED[$INDEX_DRIVE_BEING_EDITED]} )); then

					G_WHIP_MSG 'Partition must be unmounted, before format and RootFS transfer can begin.\n\nPlease unmount the partition, then try again.'

				else

					G_WHIP_YESNO "This process will move RootFS data to another location. This may increase filesystem performance when using a USB drive over SD card, however, there are some limitations:\n\n - The SD/EMMC card is still required for the boot process\n - ALL data on the target PARTITION will be deleted\n\nNB: As this feature is still in testing, we recommend you use this feature on a fresh installation only.\n\nDo you wish to continue?"
					if (( ! $? )); then

						G_WHIP_MSG 'On the next screen, you will be asked to format the target partition.\n\nPlease see the following recommendations for RootFS target filesystem type:\n\n - Odroid\nRootFS transfer supports ONLY EXT4 format\n\n - RPi\nRootFS transfer supports EXT4, BTRFS and F2FS'

						#NB: We dont enter main loop in this func
						TARGETMENUID=2
						while (( $TARGETMENUID == 2 ))
						do

							Menu_Format

						done

						if (( $FORMAT_COMPLETED )); then

							RootFS_Move

						fi

					fi

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Read Only' ]]; then

				Toggle_WriteMode

			elif [[ $G_WHIP_RETURNED_VALUE == 'Benchmark' ]]; then

				/DietPi/dietpi/func/dietpi-benchmark 0 "${aDRIVE_MOUNT_TARGET[$INDEX_DRIVE_BEING_EDITED]}"

			elif [[ $G_WHIP_RETURNED_VALUE == 'Check & Repair' ]]; then

				if (( ${aDRIVE_ISMOUNTED[$INDEX_DRIVE_BEING_EDITED]} )); then

					G_WHIP_YESNO 'For safe check and repair, the drive needs to be unmounted.\n\nDo you want to continue with the drive being unmounted automatically?'
					(( $? )) && TARGETMENUID=1 && return

					# - disable swap
					if (( $partition_contains_swapfile )); then

						G_RUN_CMD swapoff -a

					fi

					# - Unmount drive
					G_RUN_CMD umount ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}

				fi

				if [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} =~ 'ext' ]]; then

					local fsck_dry='e2fsck -n -f'
					local fsck_fix='e2fsck -y -f'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'exfat' ]]; then

					G_AG_CHECK_INSTALL_PREREQ exfat-utils exfat-fuse
					local fsck_fix='exfatfsck'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} =~ 'fat' ]]; then

					G_AG_CHECK_INSTALL_PREREQ dosfstools
					local fsck_dry='fsck.fat -n'
					local fsck_fix='fsck.fat -y'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'ntfs' ]]; then

					G_AG_CHECK_INSTALL_PREREQ ntfs-3g
					local fsck_dry='ntfsfix -n'
					local fsck_fix='ntfsfix'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} =~ 'hfs' ]]; then

					G_AG_CHECK_INSTALL_PREREQ hfsplus hfsprogs hfsutils
					local fsck_dry='fsck.hfsplus -n -f'
					local fsck_fix='fsck.hfsplus -y -f'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'f2fs' ]]; then

					G_AG_CHECK_INSTALL_PREREQ f2fs-tools
					local fsck_dry='fsck.f2fs'
					local fsck_fix='fsck.f2fs -f'

				elif [[ ${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]} == 'btrfs' ]]; then

					G_AG_CHECK_INSTALL_PREREQ btrfs-tools
					local fsck_dry='btrfs check --readonly'
					local fsck_fix='btrfs check --repair'

				else

					G_WHIP_MSG "File system checks are currently not supported for '${aDRIVE_FSTYPE[$INDEX_DRIVE_BEING_EDITED]}'. Aborting..."
					TARGETMENUID=1
					return

				fi

				# Do dry-run first for file systems supporting it:
				if [[ $fsck_dry ]]; then

					G_WHIP_MSG "The following drive will now be checked for errors:\n${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}\n\nNo repair will be completed during this process. An option to repair the drive, will be provided after the check."
					$fsck_dry ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} &> /tmp/.dietpi-drive_manager_check.log
					G_WHIP_VIEWLOG /tmp/.dietpi-drive_manager_check.log
					rm /tmp/.dietpi-drive_manager_check.log &> /dev/null

				fi

				G_WHIP_YESNO "Would you like to run an automated repair on the following drive now?\n       ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}\n
NB:
- Automated repair steps potentially lead to data loss, which would have been able to recover by professional drive recovery services.
- If the data is extremely important and you don't have any backup, you might want to hand the drive to a recovery service as is.
- These services are usually very expensive, but might be able to recover more data than (after) this automated repair steps!"
				if (( ! $? )); then

					$fsck_fix ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]} &> /tmp/.dietpi-drive_manager_repair.log
					G_WHIP_VIEWLOG /tmp/.dietpi-drive_manager_repair.log
					rm /tmp/.dietpi-drive_manager_repair.log &> /dev/null

				fi

				# - Remount all drives
				G_RUN_CMD mount -a

				# - re-enable swap
				if (( $partition_contains_swapfile )); then

					G_RUN_CMD swapon -a

				fi

			fi

		#Exit
		else

			TARGETMENUID=0

		fi

		unset whiptail_desc

		#Always init/refresh drives for next loop
		Init_Drives_and_Refresh

	}

	Menu_Format(){

		TARGETMENUID=2

		FORMAT_COMPLETED=0

		local partition_table_text='MBR'
		if (( $FORMAT_GPT )); then

			partition_table_text='GPT'

		fi

		local format_type_text='EXT4'
		if (( $FORMAT_FILESYSTEM_TYPE == 1 )); then

			format_type_text='NTFS'

		elif (( $FORMAT_FILESYSTEM_TYPE == 2 )); then

			format_type_text='FAT32'

		elif (( $FORMAT_FILESYSTEM_TYPE == 3 )); then

			format_type_text='HFS+'

		elif (( $FORMAT_FILESYSTEM_TYPE == 4 )); then

			format_type_text='BTRFS'

		elif (( $FORMAT_FILESYSTEM_TYPE == 5 )); then

			format_type_text='F2FS'

		elif (( $FORMAT_FILESYSTEM_TYPE == 6 )); then

			format_type_text='EXFAT'

		fi

		G_WHIP_MENU_ARRAY=()

		G_WHIP_MENU_ARRAY+=('Partition Type' ": $partition_table_text")
		G_WHIP_MENU_ARRAY+=('Filesystem Type' ": $format_type_text")
		G_WHIP_MENU_ARRAY+=('Format' ': Wipe all data and format drive with current options')

		G_WHIP_DEFAULT_ITEM="$MENU_LASTITEM"
		G_WHIP_MENU 'Please select formatting options:'
		if (( ! $? )); then

			MENU_LASTITEM="$G_WHIP_RETURNED_VALUE"

			if [[ $G_WHIP_RETURNED_VALUE == 'Partition Type' ]]; then

				FORMAT_GPT=1

				G_WHIP_YESNO "Would you like to use GPT or MBR parition table?\n - GPT is required for 2TB+ drives\n - MBR does NOT support 2TB+ drives\n\nIf unsure, select GPT (default)"
				if (( ! $? )); then

					FORMAT_GPT=0
					partition_table_text='MBR'

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Filesystem Type' ]]; then

				G_WHIP_MENU_ARRAY=(

					'0' ': EXT4   | Default (Recommended)'
					'1' ': NTFS   | Windows (High CPU usage)'
					'2' ': FAT32  | All OS (4GB filesize limit)'
					'3' ': HFS+   | Mac OS X (Intel Mac default file system)'
					'4' ': BTRFS  | Linux (Modern filesystem)'
					'5' ': F2FS   | Linux (Flash filesystem)'
					'6' ': exFAT  | Windows (Flash filesystem)'

				)

				G_WHIP_DEFAULT_ITEM="$FORMAT_FILESYSTEM_TYPE"
				G_WHIP_MENU "Please select a filesystem type for this format:\n\nEXT4:\nHighly recommended if you plan to use this drive solely on this system (dedicated drive).\n\nNTFS:\nRecommended if you plan to use this drive on a Windows system. High CPU usage during transfers.\n\nFull list of different filesystem types:\nhttp://dietpi.com/phpbb/viewtopic.php?f=8&t=673&p=2898#p2898"
				if (( ! $? )); then

					# Install FS pre-reqs
					# - NTFS
					if (( $G_WHIP_RETURNED_VALUE == 1 )); then

						G_AG_CHECK_INSTALL_PREREQ ntfs-3g

					# - FAT32
					elif (( $G_WHIP_RETURNED_VALUE == 2 )); then

						G_AG_CHECK_INSTALL_PREREQ dosfstools

					# - HFS+
					elif (( $G_WHIP_RETURNED_VALUE == 3 )); then

						G_AG_CHECK_INSTALL_PREREQ hfsplus hfsprogs hfsutils

					# - Btrfs
					elif (( $G_WHIP_RETURNED_VALUE == 4 )); then

						G_AG_CHECK_INSTALL_PREREQ btrfs-tools

 					# - F2FS
					elif (( $G_WHIP_RETURNED_VALUE == 5 )); then

						G_AG_CHECK_INSTALL_PREREQ f2fs-tools

					# - exFAT
					elif (( $G_WHIP_RETURNED_VALUE == 6 )); then

						G_AG_CHECK_INSTALL_PREREQ exfat-utils exfat-fuse

					fi

					FORMAT_FILESYSTEM_TYPE="$G_WHIP_RETURNED_VALUE"

				fi

			elif [[ $G_WHIP_RETURNED_VALUE == 'Format' ]]; then

				local text_desc="Format Drive:\n - /dev/${aDRIVE_SOURCE_DEVICE[$INDEX_DRIVE_BEING_EDITED]}\n - UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}\n - Partition table: $partition_table_text\n - Filesystem type: $format_type_text\n\nALL DATA and PARTITIONS on this drive will be DELETED.\nDo you wish to continue?"

				if (( ! $FORMAT_RECREATE_PARTITION_TABLE )); then

					text_desc="Format partition:\n - ${aDRIVE_MOUNT_SOURCE[$INDEX_DRIVE_BEING_EDITED]}\n - UUID=${aDRIVE_UUID[$INDEX_DRIVE_BEING_EDITED]}\n - Partition table: $partition_table_text\n - Filesystem type: $format_type_text\n\nALL DATA on this partition will be DELETED.\nDo you wish to continue?"

				fi

				G_WHIP_YESNO "Start format?\n\n$text_desc"
				if (( ! $? )); then

					Run_Format

					TARGETMENUID=1

				fi

			fi

		else

			TARGETMENUID=1

		fi

	}

	Mount_Samba(){

		rm /mnt/samba/readme.txt &> /dev/null

		local samba_clientname=''
		local samba_clientshare=''
		local samba_clientuser=''
		local samba_clientpassword=''
		local samba_fp_mount_target='samba'

		while true
		do

			G_WHIP_DEFAULT_ITEM="$samba_clientname"
			G_WHIP_INPUTBOX 'Please enter the fileservers IP address\n - eg: 192.168.0.2'
			if (( $? != 0 )); then

				break

			fi
			samba_clientname=$G_WHIP_RETURNED_VALUE

			G_WHIP_DEFAULT_ITEM="$samba_clientshare"
			G_WHIP_INPUTBOX 'Please enter the fileservers shared folder name\n - eg: MySharedFolder'
			if (( $? != 0 )); then

				break

			fi
			samba_clientshare=$G_WHIP_RETURNED_VALUE

			G_WHIP_DEFAULT_ITEM="$samba_clientuser"
			G_WHIP_INPUTBOX 'Please enter the fileservers username\n - eg: JoeBloggs'
			if (( $? != 0 )); then

				break

			fi
			samba_clientuser=$G_WHIP_RETURNED_VALUE

			G_WHIP_DEFAULT_ITEM="$samba_clientpassword"
			G_WHIP_INPUTBOX 'Please enter the fileservers password\n - eg: LetMeIn'
			if (( $? != 0 )); then

				break

			fi
			samba_clientpassword=$G_WHIP_RETURNED_VALUE

			G_WHIP_DEFAULT_ITEM="$samba_fp_mount_target"
			G_WHIP_INPUTBOX 'Please enter a unique folder name for the mount location (eg: samba). This will be placed in /mnt/'
			if (( $? != 0 )); then

				break

			fi
			samba_fp_mount_target="/mnt/$(echo -e $G_WHIP_RETURNED_VALUE | sed 's/\///g' | sed 's/[[:space:]]/_/g')"

			# - Unmount if connected
			umount /mnt/$samba_fp_mount_target &> /dev/null

			G_AG_CHECK_INSTALL_PREREQ smbclient cifs-utils

			#NB: Convert spaces into '\040': https://github.com/Fourdee/DietPi/issues/1201#issuecomment-339720271
			local space_to_040=$(echo -e "$samba_clientshare" | sed 's/ /\\\\040/g')

			#Mount now
			mkdir -p $samba_fp_mount_target

			G_RUN_CMD_INFO_ONLY=1 G_RUN_CMD mount -t cifs -o username=$samba_clientuser,password=$samba_clientpassword //$samba_clientname/$space_to_040 $samba_fp_mount_target
			if (( ! $G_ERROR_HANDLER_EXITCODE_RETURN )); then

				#Apply to fstab
				sed -i "\#[[:space:]]$samba_fp_mount_target[[:space:]]#d" /etc/fstab
				cat << _EOF_ >> /etc/fstab
//$samba_clientname/$space_to_040 $samba_fp_mount_target cifs username=$samba_clientuser,password=$samba_clientpassword,iocharset=utf8,vers=1.0,nofail 0 0
_EOF_

				G_WHIP_MSG "Mount completed. The new mount can be accessed via:\n - $samba_fp_mount_target"

			else

				rm -R $samba_fp_mount_target

			fi

			break

		done

	}

	Mount_NFS(){

		rm /mnt/nfs_client/readme.txt &> /dev/null

		local nfs_clientname=''
		local nfs_fp_mount_target='nfs'

		while true
		do

			G_WHIP_DEFAULT_ITEM="$nfs_clientname"
			G_WHIP_INPUTBOX 'Please enter the fileservers IP address\n - eg: 192.168.0.2'
			if (( $? != 0 )); then

				break

			fi
			nfs_clientname=$G_WHIP_RETURNED_VALUE

			G_WHIP_DEFAULT_ITEM="$nfs_fp_mount_target"
			G_WHIP_INPUTBOX 'Please enter a unique folder name for the mount location (eg: samba). This will be placed in /mnt/'
			if (( $? != 0 )); then

				break

			fi
			nfs_fp_mount_target="/mnt/$(echo -e $G_WHIP_RETURNED_VALUE | sed 's/\///g' | sed 's/[[:space:]]/_/g')"

			# - Unmount if connected
			umount /mnt/$nfs_fp_mount_target &> /dev/null

			G_AG_CHECK_INSTALL_PREREQ nfs-common

			#Mount now
			mkdir -p $nfs_fp_mount_target

			G_RUN_CMD_INFO_ONLY=1 G_RUN_CMD mount -t nfs4 -o port=2049 $nfs_clientname:/ $nfs_fp_mount_target
			if (( ! $G_ERROR_HANDLER_EXITCODE_RETURN )); then

				#Apply to fstab
				sed -i "\#[[:space:]]$nfs_fp_mount_target[[:space:]]#d" /etc/fstab
				cat << _EOF_ >> /etc/fstab
$nfs_clientname:/ $nfs_fp_mount_target nfs4 auto,_netdev 0  0
_EOF_

				G_WHIP_MSG "Mount completed. The new mount can be accessed via:\n - $nfs_fp_mount_target"

			else

				rm -R $nfs_fp_mount_target

			fi

			break

		done

	}

	Menu_Add_Network_Drive(){

		TARGETMENUID=3

		G_WHIP_MENU_ARRAY=(

			'Samba' 'Setup a connection for a Samba/CIFS/Windows compatible file share'
			'NFS' 'Setup a connection for a NFS compatible file share'

		)

		G_WHIP_MENU 'Please select a mount location to use:'
		if (( $? == 0 )); then

			if [[ $G_WHIP_RETURNED_VALUE == 'Samba' ]]; then

				Mount_Samba

			elif [[ $G_WHIP_RETURNED_VALUE == 'NFS' ]]; then

				Mount_NFS

			fi

			Init_Drives_and_Refresh

		else

			TARGETMENUID=0

		fi

	}

	Menu_Select_Mount_Location(){

		#Generate menu
		G_WHIP_MENU_ARRAY=()

		df -Ph | tail -n +2 | sed '/tmpfs/d' | sed '/^udev/d' > /tmp/dietpi-drive_manager_selmnt

		while read line
		do

			G_WHIP_MENU_ARRAY+=("$(echo -e $line | awk '{print $6}')" ": $(echo -e $line | awk '{print $1}') | size: $(echo -e $line | awk '{print $2}') | available: $(echo -e $line | awk '{print $4}')")

		done < /tmp/dietpi-drive_manager_selmnt
		rm /tmp/dietpi-drive_manager_selmnt

		G_WHIP_DEFAULT_ITEM="$MENU_LASTITEM"
		G_WHIP_MENU 'Please select a mount location to use:'
		if (( ! $? )); then

			local drive_manager_selection="$G_WHIP_RETURNED_VALUE"

			G_DIETPI-NOTIFY 0 "Drive mount selected: $drive_manager_selection"
			echo -e "$drive_manager_selection" > "$FP_DRIVE_MANAGER_SELECTION"

		fi

	}

	Menu_Exit(){

		G_WHIP_SIZE_X_MAX=50
		G_WHIP_YESNO "Exit $G_PROGRAM_NAME?"
		if (( ! $? )); then

			#exit
			TARGETMENUID=-1

		else

			#Return to Main Menu
			TARGETMENUID=0

		fi

	}

	#/////////////////////////////////////////////////////////////////////////////////////
	# Main Loop
	#/////////////////////////////////////////////////////////////////////////////////////
	if (( $INPUT >= 1 )); then

		SERVICE_CONTROL=0

	fi
	#-----------------------------------------------------------------------------------
	# Stop Services
	if (( $SERVICE_CONTROL )); then

		/DietPi/dietpi/dietpi-services stop

	fi
	#-----------------------------------------------------------------------------------
	#Generate /etc/fstab based on current drive mounts
	if (( $INPUT == 4 )); then

		Init_Drives_and_Refresh

	#Return 1 if RootFS is RO
	elif (( $INPUT == 3 )); then

		RootFS_RW_Check

	#Menu system for user to select an active mount and return value
	elif (( $INPUT == 1 )); then

		Init_Drives_and_Refresh
		Menu_Select_Mount_Location

	#Drive Manager
	else

		Init_Drives_and_Refresh

		while (( $TARGETMENUID > -1 )); do

			printf '\ec'

			if (( $TARGETMENUID == 0 )); then

				Menu_Main_Drive_Manager

			elif (( $TARGETMENUID == 1 )); then

				Menu_Drive_Manager_Edit_Drive

			elif (( $TARGETMENUID == 2 )); then

				Menu_Format

			elif (( $TARGETMENUID == 3 )); then

				Menu_Add_Network_Drive

			fi

		done

	fi
	#-----------------------------------------------------------------------------------
	#Destroy
	Destroy

	#-----------------------------------------------------------------------------------
	# Start Services
	if (( $SERVICE_CONTROL )); then

		/DietPi/dietpi/dietpi-services start

	fi
	#-----------------------------------------------------------------------------------
	exit $EXIT_CODE
	#-----------------------------------------------------------------------------------
}
